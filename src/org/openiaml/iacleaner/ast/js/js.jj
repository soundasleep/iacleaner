/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\js.jj */
/*@egen*/
options {
             
               
  // NODE_DEFAULT_VOID=true; /* makes all nodes #void by default, reducing the number of elements generated */
}

PARSER_BEGIN(Javascript)

package org.openiaml.iacleaner.ast.js;

import java.util.*;
import java.io.*;

/** A grammar for web applications, maybe? */
public class Javascript/*@bgen(jjtree)*/implements JavascriptTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTJavascriptState jjtree = new JJTJavascriptState();

/*@egen*/

  public static Javascript instance = null;
  
  /**
   * For loading test cases programatically.
   */
  public static SimpleNode loadFile(File f, int initialState) throws ParseException, FileNotFoundException {
  	FileInputStream fis = new FileInputStream(f);
  	if (instance == null) {
  		instance = new Javascript(fis);
  	} else {
  		ReInit(fis);
  	}
  	JavascriptTokenManager.SwitchTo(initialState);
  	SimpleNode n;
  	n = StartJs();
  	return n;
  }

  /**
   * For loading test cases programatically.
   * Works out the initial state based on the file extension of the given
   * file.
   */
  public static SimpleNode loadFile(File f) throws ParseException, FileNotFoundException {
	  String extension = f.getAbsolutePath().substring(f.getAbsolutePath().lastIndexOf("."));
	  
	  int initialState = 0;
	  if (extension.equals(".js")) {
	  	initialState = JS_STATE;
	  } else {
	  	throw new RuntimeException("Unknown file type: " + extension + " (from file: " + f + ")");
	  }
	  
	  return loadFile(f, initialState);
  }

  /**
   * Loading string sources.
   * 
   * @throws UnsupportedEncodingException if we have a problem with the charset encoding 
   */
  public static SimpleNode loadString(String s, String charset, int initialState) throws ParseException, FileNotFoundException, UnsupportedEncodingException {
	  InputStream fis = new ByteArrayInputStream(s.getBytes(charset));
 	if (instance == null) {
  		instance = new Javascript(fis);
  	} else {
  		ReInit(fis);
  	}
  	JavascriptTokenManager.SwitchTo(initialState);
  	SimpleNode n;
  	n = StartJs();
  	return n;
  }

  /** Loads string sources with a default state of JS. */
  public static SimpleNode loadString(String s, String charset) throws ParseException, FileNotFoundException, UnsupportedEncodingException {
  	return loadString(s, charset, JS_STATE);
  }
  
}

PARSER_END(Javascript)

<JS_STATE>
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "/*" : JS_WITHIN_COMMENT
| "//" : JS_WITHIN_COMMENT_SINGLE
}

/* order also matters: by placing this before the matchall, the comments will be properly ended. */
<JS_WITHIN_COMMENT>
SKIP:
{
	< "*/" > : JS_STATE
}

<JS_WITHIN_COMMENT>
MORE:
{
	< ~[] >
}

/* order also matters: by placing this before the matchall, the comments will be properly ended. */
<JS_WITHIN_COMMENT_SINGLE>
SKIP:
{
	< ["\r","\n"] > : JS_STATE
}

<JS_WITHIN_COMMENT_SINGLE>
MORE:
{
	< ~["\r","\n"] >
}

/** --- javascript --- */
<JS_STATE>
TOKEN :
{
	< JS_FUNCTION_STATEMENT: "function" >
}

<JS_STATE>
TOKEN :
{
	< JS_RETURN_STATEMENT: "return" >
}

<JS_STATE>
TOKEN :
{
	< JS_NEW_STATEMENT: "new" >
}

<JS_STATE>
TOKEN :
{
	< JS_VAR_STATEMENT: "var" >
}

<JS_STATE>
TOKEN : /* if statement */
{
	< JS_IF_STATEMENT:
		"if" >
}

<JS_STATE>
TOKEN :
{
	< JS_FOR_STATEMENT: "for" >
}

<JS_STATE>
TOKEN :
{
	< JS_TRY_STATEMENT: "try" >
}

<JS_STATE>
TOKEN :
{
	< JS_CATCH_STATEMENT: "catch" >
}

<JS_STATE>
TOKEN :
{
	< JS_THROW_STATEMENT: "throw" >
}

<JS_STATE>
TOKEN :
{
	< JS_FINALLY_STATEMENT: "finally" >
}

/**
 * if we use constants in the rules below, they cannot be reused
 * across different lexical states (I think)
 */
<JS_STATE>
TOKEN : { < JS_BRACKET_OPEN: "(" > }
<JS_STATE>
TOKEN : { < JS_BRACKET_CLOSE: ")" > }
<JS_STATE>
TOKEN : { < JS_BRACE_OPEN: "{" > }
<JS_STATE>
TOKEN : { < JS_BRACE_CLOSE: "}" > }
<JS_STATE>
TOKEN : { < JS_ARRAY_OPEN: "[" > }
<JS_STATE>
TOKEN : { < JS_ARRAY_CLOSE: "]" > }
<JS_STATE>
TOKEN : { < JS_END: ";" > }
<JS_STATE>
TOKEN : { < JS_COMMA: "," > }

<JS_STATE>
TOKEN : /* else statement */
{
	< JS_ELSE_STATEMENT:
		"else" >
}

<JS_STATE>
TOKEN : /* STRING */
{
	< JS_STRING:
		"\"" ("\\\"" | (~["\""]))* "\"" >
}

<JS_STATE>
TOKEN : /* STRING (single quoted) */
{
	< JS_STRING_SQ:
		"'" ("\\'" | (~["'"]))* "'" >
}

<JS_STATE>
TOKEN : /* Decimal */
{
	< JS_DECIMAL:
		(["0"-"9"])+
		( "." (["0"-"9"]) * )? >	/* can have numbers after the decimal point */
}

<JS_STATE>
TOKEN : /* Hexaecimal */
{
	< JS_HEXADECIMAL:
		"0x" (["0"-"9","a"-"f"])+ >
}

<JS_STATE>
TOKEN : /* built in variables */
{
	< JS_BUILTIN:
		"true" | "false" | "null" >
}

<JS_STATE>
TOKEN : /* operator */
{
	< JS_OBJECT_OPERATOR: "." >
}

<JS_STATE>
TOKEN : /* prefix operators, e.g. !false */
{
	< JS_PREFIX_OPERATOR:
		"!" >
}

<JS_STATE>
TOKEN : /* both prefix and operators e.g. -3 and 1-3 */
{
	< JS_NUMBER_OPERATOR:
		"-" | "+" >
}

<JS_STATE>
TOKEN : /* operator */
{
	< JS_OPERATOR:
		"*" | "/" | "%" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "&&" | "||" | "instanceof" >
}

<JS_STATE>
TOKEN : /* operator */
{
	< JS_ASSIGNMENT_OPERATOR:
		"+=" | "-=" | "&=" | "|=" >
}

<JS_STATE>
TOKEN : /* single operators */
{
	< JS_OPERATOR_SINGLE:
		"++" | "--" >
}

<JS_STATE>
TOKEN : { < JS_EQUAL: "=" > }

<JS_STATE>
TOKEN :
{
	< JS_TERNARY_1: "?" >
}

<JS_STATE>
TOKEN : 
{
	< JS_TERNARY_2: ":" >
}

<JS_STATE>
TOKEN : /* Function name */
{
	< JS_VARIABLE:
		["A"-"Z","a"-"z","_","$"] (["0"-"9","A"-"Z","a"-"z","_"])* >
}

<JS_STATE>
TOKEN : /* Function name */
{
	< JS_SCRIPT_END: "</script>" >
}

/* JS_VARIABLE === JS_FUNCTION_NAME */

/** Main production. */
SimpleNode StartJs() : {/*@bgen(jjtree) StartJs */
                         ASTStartJs jjtn000 = new ASTStartJs(JJTSTARTJS);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ SimpleNode n; }
{/*@bgen(jjtree) StartJs */
        try {
/*@egen*/
	JsBlock() { n = jjtn000; }
	( <JS_SCRIPT_END> )?
	<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return n; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsBlock() : {/*@bgen(jjtree) JsBlock */
  ASTJsBlock jjtn000 = new ASTJsBlock(JJTJSBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsBlock */
        try {
/*@egen*/
	( LOOKAHEAD(1) JsStatement() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsStatement() : {/*@bgen(jjtree) JsStatement */
  ASTJsStatement jjtn000 = new ASTJsStatement(JJTJSSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsStatement */
        try {
/*@egen*/
	JsFunctionDefinition() 
	| JsIfStatement()
	| JsForStatement()
	| JsLanguageStatement()
	| (<JS_BRACE_OPEN> JsBlock() <JS_BRACE_CLOSE>)
	| JsTryCatchBlock()
	| JsThrowStatement()
	| <JS_END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ /* ";" can be anywhere in js scripts */
}

void JsLanguageStatement() : {/*@bgen(jjtree) JsLanguageStatement */
  ASTJsLanguageStatement jjtn000 = new ASTJsLanguageStatement(JJTJSLANGUAGESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsLanguageStatement */
        try {
/*@egen*/
	JsReturnStatement()
	| ( <JS_VAR_STATEMENT> <JS_VARIABLE> (<JS_EQUAL> JsValuePossiblyWrapped())? )
	| (
		<JS_VARIABLE> JsTraverseObjects()
		(((<JS_EQUAL> | <JS_ASSIGNMENT_OPERATOR>) JsValuePossiblyWrapped())
			| <JS_OPERATOR_SINGLE>) ?
	)
	| (JsNewStatement() JsTraverseObjects())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsTraverseObjects() : {/*@bgen(jjtree) JsTraverseObjects */
  ASTJsTraverseObjects jjtn000 = new ASTJsTraverseObjects(JJTJSTRAVERSEOBJECTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsTraverseObjects */
        try {
/*@egen*/
	(
		(<JS_BRACKET_OPEN> (JsArgumentList())? <JS_BRACKET_CLOSE>)
		| (<JS_OBJECT_OPERATOR> <JS_VARIABLE>)
		| ( JsSelectArray())
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsSelectArray() : {/*@bgen(jjtree) JsSelectArray */
  ASTJsSelectArray jjtn000 = new ASTJsSelectArray(JJTJSSELECTARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsSelectArray */
        try {
/*@egen*/
	<JS_ARRAY_OPEN> JsValuePossiblyWrapped() <JS_ARRAY_CLOSE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void JsReturnStatement() : {/*@bgen(jjtree) JsReturnStatement */
  ASTJsReturnStatement jjtn000 = new ASTJsReturnStatement(JJTJSRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsReturnStatement */
        try {
/*@egen*/
	<JS_RETURN_STATEMENT> (LOOKAHEAD(1) JsValuePossiblyWrapped())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsNewStatement() : {/*@bgen(jjtree) JsNewStatement */
  ASTJsNewStatement jjtn000 = new ASTJsNewStatement(JJTJSNEWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsNewStatement */
        try {
/*@egen*/
	<JS_NEW_STATEMENT> <JS_VARIABLE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ /* brackets are optional */
}

void JsValue() : {/*@bgen(jjtree) JsValue */
  ASTJsValue jjtn000 = new ASTJsValue(JJTJSVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsValue */
        try {
/*@egen*/
	(
	  <JS_VARIABLE>
	  | JsNewStatement() 
	  | JsAnonymousFunction()
	  | JsSimpleValue()
	  | (<JS_BRACE_OPEN> (JsInlineArray())? <JS_BRACE_CLOSE>) )		/* inline arrays: foo{a:b, c:d} */

	/* we can do crazy things, like "foo".indexOf() */
  	(JsTraverseObjects() )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}

void JsValuePossiblyWrapped() : {/*@bgen(jjtree) JsValuePossiblyWrapped */
  ASTJsValuePossiblyWrapped jjtn000 = new ASTJsValuePossiblyWrapped(JJTJSVALUEPOSSIBLYWRAPPED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsValuePossiblyWrapped */
        try {
/*@egen*/
	( <JS_PREFIX_OPERATOR> )*
	
	(( <JS_BRACKET_OPEN> JsValuePossiblyWrapped() <JS_BRACKET_CLOSE> ) | JsValue() )

	(
		/* e.g. "f() *+ 42" */
		(<JS_OPERATOR> JsValuePossiblyWrapped())
		|
		/* e.g. "f() + 42" */
		(<JS_NUMBER_OPERATOR> JsValuePossiblyWrapped())
		|
		/* e.g. "f() += 42" */
		(<JS_ASSIGNMENT_OPERATOR> JsValuePossiblyWrapped())
		|
		/* e.g. "f() = 42" */
		(<JS_EQUAL> JsValuePossiblyWrapped())
		|
		/* e.g. "f() ? 1 : 2" */
		(<JS_TERNARY_1> JsValuePossiblyWrapped() <JS_TERNARY_2> JsValuePossiblyWrapped())
		|
		/* e.g. "f++" */
		(<JS_OPERATOR_SINGLE>)
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void JsSimpleValue() : {/*@bgen(jjtree) JsSimpleValue */
  ASTJsSimpleValue jjtn000 = new ASTJsSimpleValue(JJTJSSIMPLEVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsSimpleValue */
        try {
/*@egen*/
	<JS_STRING> 
	| <JS_STRING_SQ> 
	| ((<JS_NUMBER_OPERATOR>)* <JS_DECIMAL>) 
	| <JS_HEXADECIMAL> 
	| <JS_BUILTIN>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsArgumentList() : {/*@bgen(jjtree) JsArgumentList */
  ASTJsArgumentList jjtn000 = new ASTJsArgumentList(JJTJSARGUMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsArgumentList */
        try {
/*@egen*/
	JsValuePossiblyWrapped() (<JS_COMMA> JsArgumentList())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsVariableList() : {/*@bgen(jjtree) JsVariableList */
  ASTJsVariableList jjtn000 = new ASTJsVariableList(JJTJSVARIABLELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsVariableList */
        try {
/*@egen*/
	<JS_VARIABLE> (<JS_COMMA> JsVariableList())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsFunctionDefinition() : {/*@bgen(jjtree) JsFunctionDefinition */
  ASTJsFunctionDefinition jjtn000 = new ASTJsFunctionDefinition(JJTJSFUNCTIONDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsFunctionDefinition */
        try {
/*@egen*/
	<JS_FUNCTION_STATEMENT> 
	<JS_VARIABLE> <JS_BRACKET_OPEN> (JsFunctionArgumentList()) ? <JS_BRACKET_CLOSE>
	<JS_BRACE_OPEN>
		JsBlock()
	<JS_BRACE_CLOSE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsFunctionArgumentList() : {/*@bgen(jjtree) JsFunctionArgumentList */
  ASTJsFunctionArgumentList jjtn000 = new ASTJsFunctionArgumentList(JJTJSFUNCTIONARGUMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsFunctionArgumentList */
        try {
/*@egen*/
	<JS_VARIABLE>
	( <JS_EQUAL> JsSimpleValue() )?
	( <JS_COMMA> JsFunctionArgumentList() )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsAnonymousFunction() : {/*@bgen(jjtree) JsAnonymousFunction */
  ASTJsAnonymousFunction jjtn000 = new ASTJsAnonymousFunction(JJTJSANONYMOUSFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsAnonymousFunction */
        try {
/*@egen*/
	<JS_FUNCTION_STATEMENT> 
	<JS_BRACKET_OPEN> (JsFunctionArgumentList()) ? <JS_BRACKET_CLOSE>
	<JS_BRACE_OPEN>
		JsBlock()
	<JS_BRACE_CLOSE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsIfStatement() : {/*@bgen(jjtree) JsIfStatement */
  ASTJsIfStatement jjtn000 = new ASTJsIfStatement(JJTJSIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsIfStatement */
        try {
/*@egen*/
	<JS_IF_STATEMENT> 
		<JS_BRACKET_OPEN> JsValuePossiblyWrapped() <JS_BRACKET_CLOSE>		
			JsBlock()
	( LOOKAHEAD(2) <JS_ELSE_STATEMENT> 
		( JsBlock() ) ) ?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsForStatement() : {/*@bgen(jjtree) JsForStatement */
  ASTJsForStatement jjtn000 = new ASTJsForStatement(JJTJSFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsForStatement */
        try {
/*@egen*/
	<JS_FOR_STATEMENT> 
	<JS_BRACKET_OPEN> 
	(JsForParameterList())? <JS_END> 
	(JsForEvaluateParameterList())? <JS_END> 
	(JsForEvaluateParameterList())?
	<JS_BRACKET_CLOSE> 
	<JS_BRACE_OPEN> JsBlock() <JS_BRACE_CLOSE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsForParameterList() : {/*@bgen(jjtree) JsForParameterList */
  ASTJsForParameterList jjtn000 = new ASTJsForParameterList(JJTJSFORPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsForParameterList */
        try {
/*@egen*/
	JsLanguageStatement()
	(<JS_COMMA> JsForParameterList())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsForEvaluateParameterList() : {/*@bgen(jjtree) JsForEvaluateParameterList */
  ASTJsForEvaluateParameterList jjtn000 = new ASTJsForEvaluateParameterList(JJTJSFOREVALUATEPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsForEvaluateParameterList */
        try {
/*@egen*/
	JsValuePossiblyWrapped()
	(<JS_COMMA> JsForEvaluateParameterList())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* inline arrays: { a:3, b:function() {...}, c:"kittens", } */
void JsInlineArray() : {/*@bgen(jjtree) JsInlineArray */
  ASTJsInlineArray jjtn000 = new ASTJsInlineArray(JJTJSINLINEARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsInlineArray */
        try {
/*@egen*/
	(LOOKAHEAD(2) <JS_VARIABLE> <JS_TERNARY_2>) ?
	JsValuePossiblyWrapped()
	(<JS_COMMA> (JsInlineArray()) ?) ?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsThrowStatement() : {/*@bgen(jjtree) JsThrowStatement */
  ASTJsThrowStatement jjtn000 = new ASTJsThrowStatement(JJTJSTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsThrowStatement */
        try {
/*@egen*/
	<JS_THROW_STATEMENT> JsValue()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void JsTryCatchBlock() : {/*@bgen(jjtree) JsTryCatchBlock */
  ASTJsTryCatchBlock jjtn000 = new ASTJsTryCatchBlock(JJTJSTRYCATCHBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) JsTryCatchBlock */
        try {
/*@egen*/
	<JS_TRY_STATEMENT> <JS_BRACE_OPEN>
		JsBlock()
	<JS_BRACE_CLOSE>
	(<JS_CATCH_STATEMENT> <JS_BRACKET_OPEN> <JS_VARIABLE> (<JS_IF_STATEMENT> JsValuePossiblyWrapped())? <JS_BRACKET_CLOSE> <JS_BRACE_OPEN>
		JsBlock()
	<JS_BRACE_CLOSE>)*
	(<JS_FINALLY_STATEMENT> <JS_BRACE_OPEN>
		JsBlock()
	<JS_BRACE_CLOSE>)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
